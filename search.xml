<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[开机自动后台运行VirtualBox虚拟机]]></title>
      <url>http://fanjun.im/2017/11/JDK8_Lambda.html</url>
      <content type="html"><![CDATA[<h1 id="JDK8-Lambda"><a href="#JDK8-Lambda" class="headerlink" title="JDK8 Lambda"></a>JDK8 Lambda</h1><h2 id="一、lambda表达式"><a href="#一、lambda表达式" class="headerlink" title="一、lambda表达式"></a>一、lambda表达式</h2><h3 id="1、方法引用"><a href="#1、方法引用" class="headerlink" title="1、方法引用"></a>1、方法引用</h3><ul>
<li>对象::实例方法（可以引用this、super）</li>
<li>类::静态方法</li>
<li>类::实例方法</li>
</ul>
<p>前二种情况，方法引用等同于提供方法参数的lamdba表达式</p>
<blockquote>
<p>System.out::println 等同于 System.out.println(x)<br>Math::pow 等同于 (x,y)-&gt;Math.pow(x,y)</p>
</blockquote>
<p>第三种情况，第一个参数会成为执行方法的对象</p>
<blockquote>
<p>String::compareToIgnoreCare 等同于 (x,y)-&gt; x.compareToIgnoreCase(y)</p>
</blockquote>
<h3 id="2、构造器引用"><a href="#2、构造器引用" class="headerlink" title="2、构造器引用"></a>2、构造器引用</h3><ul>
<li>对象构造器   Button::new</li>
<li>数组构造器   Button[]::new<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Button[] buttons = stream.toArray(Button[]::<span class="keyword">new</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3、变量作用域"><a href="#3、变量作用域" class="headerlink" title="3、变量作用域"></a>3、变量作用域</h3><ul>
<li><p>lambda表达式可以捕获闭合作用域汇中的变量值，但是被引用的变量值不可以被修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">repeatMessage</span><span class="params">(String text/ <span class="keyword">int</span> count)</span></span>&#123;</div><div class="line">	Runnable r = () -&gt; &#123; </div><div class="line">		<span class="keyword">while</span> (count &gt; <span class="number">0</span>)&#123;</div><div class="line">			count--; <span class="comment">//不能更改已捕获变量的值</span></div><div class="line">			System.out.printIn(text);</div><div class="line">			Thread.yield();</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">new</span> Thread(r).stare()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>lambda表达式的方法体与嵌套代码块有着相同的作用域，也适用同样的命名冲突和屏蔽规则</p>
</li>
</ul>
<h3 id="4、接口的默认方法（default）"><a href="#4、接口的默认方法（default）" class="headerlink" title="4、接口的默认方法（default）"></a>4、接口的默认方法（default）</h3><p>默认方法：允许接口包含带有具体实现的方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span></span>&#123;</div><div class="line">	<span class="function"><span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="string">"XXX"</span>;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以代替传统模式：提供一个接口，以及实现该接口大部分或全部方法的抽象类。<br>父类、接口默认方法，生效规则：</p>
<ol>
<li>选择父类中的方法（类优先）。如果父类提供了具体的实现方法，那么接口中具有对应的默认方法被忽略</li>
<li>接口冲突。如果父接口提供了一个默认方法，而另一个接口也提供了一个相同的默认方法，那么你必须通过覆盖该方法来解决冲突</li>
</ol>
<h3 id="5-接口的静态方法（static）"><a href="#5-接口的静态方法（static）" class="headerlink" title="5. 接口的静态方法（static）"></a>5. 接口的静态方法（static）</h3><blockquote>
<p>针对接口的工厂类没有什么存在的必要了，直接在接口里加静态方法即可。<br>针对接口的抽象类没有什么存在的必要了，直接在接口里加默认方法即可。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Comparator.comparing(String::length)</div></pre></td></tr></table></figure>
<h2 id="二、StreamAPI"><a href="#二、StreamAPI" class="headerlink" title="二、StreamAPI"></a>二、StreamAPI</h2><h3 id="1-迭代器到Stream"><a href="#1-迭代器到Stream" class="headerlink" title="1.迭代器到Stream"></a>1.迭代器到Stream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">List.stream()</div><div class="line">list.parellelStream()</div></pre></td></tr></table></figure>
<h3 id="2-对象到Stream"><a href="#2-对象到Stream" class="headerlink" title="2.对象到Stream"></a>2.对象到Stream</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>. Stream.of(from)</div><div class="line"><span class="number">2</span>. Arrays.Stream(array,from,to)</div><div class="line"><span class="number">3</span>. Stream&lt;String&gt; silence = Stream.empty();	<span class="comment">// 空stream</span></div><div class="line"><span class="number">4</span>. Stream&lt;Double&gt; randoms = Stream.generate(Math::random);	<span class="comment">// 生产随机数Stream</span></div><div class="line"><span class="number">5</span>. Stream&lt;BigInteger&gt; integers = Stream.iterate(BigInteger.ZERO, n-&gt;n.add(BigInteger.ONE))	<span class="comment">// 生产无限序列，第一个参数是seed，第二个参数是f（seed）生成下一个数，UnaryOperator&lt;T&gt;接口的对象</span></div><div class="line"><span class="number">6</span>. Pattern、Files等都能提供方法生成Stream</div></pre></td></tr></table></figure>
<h3 id="3-Optional"><a href="#3-Optional" class="headerlink" title="3.Optional"></a>3.Optional</h3><p>1.<code>Optional&lt;T&gt;</code>对象或者是对一个T类型对象的封装，或者表示不是任务对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用</span></div><div class="line">optionValue.ifPresent(results::add);</div><div class="line">Optional&lt;Boolean&gt; added = optionalValue.map(results:add)</div><div class="line">String result = optionString.orElse(<span class="string">""</span>)</div><div class="line">String result = optionString.orElseGet(()-&gt;System.getProperty(<span class="string">"user.dir"</span>))</div><div class="line"></div><div class="line"><span class="comment">//创建</span></div><div class="line">Optional.of(result)</div><div class="line">Optional.empty()</div><div class="line">Optional.ofNullable(obj); <span class="comment">//obj==null,返回Optional.empty();否则返回Optional.of(obj)</span></div></pre></td></tr></table></figure>
<p>2.使用flatMap来组合Optional函数</p>
<h3 id="4-聚合操作"><a href="#4-聚合操作" class="headerlink" title="4.聚合操作"></a>4.聚合操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> result = words.reduce(<span class="number">0</span>, (total, word) -&gt; total + word.length(), (total1, total2) -&gt; total1 + total2);</div></pre></td></tr></table></figure>
<h3 id="5-收集结果"><a href="#5-收集结果" class="headerlink" title="5.收集结果"></a>5.收集结果</h3><p>1) List<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; result = stream.collect(Collectors.toList())</div><div class="line">Set&lt;String&gt; result = stream.collect(Collectors.toSet())</div><div class="line"></div><div class="line"><span class="comment">// 拼接字符创</span></div><div class="line">String result = stream.collect(Collectors.joining(<span class="string">","</span>))</div><div class="line">String result = stream.map(Object::toString).collect(Collectors.joining(<span class="string">","</span>))</div></pre></td></tr></table></figure></p>
<p>如果要将流的结果聚合为一个综合、平均值、最大值或最小值，那么请使用summarizingXXX方法中的一种，</p>
<p>2) Map<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Stream&lt;Locale&gt; locales = Stream.of(Locale.getAvailableLocales());</div><div class="line"></div><div class="line">Map&lt;String, Set&lt;String&gt;&gt; languageNames = locales.collect(</div><div class="line">    Collectors.toMap(</div><div class="line">        l -&gt; l.getDisplayCountry(), <span class="comment">// key</span></div><div class="line">        l -&gt; Collections.singleton(l.getDisplayLangeuage(), <span class="comment">//value</span></div><div class="line">        (a,b) -&gt; &#123;  <span class="comment">// 冲突解决，a和b的组合</span></div><div class="line">            Set&lt;String&gt; r = <span class="keyword">new</span> HashSet&lt;&gt;(a);</div><div class="line">            r.addAll(b);</div><div class="line">            <span class="keyword">return</span> r;</div><div class="line">        &#125;</div><div class="line">    ));</div><div class="line"><span class="comment">// 等同</span></div><div class="line">Map&lt;String, List&lt;Locale&gt;&gt; countryToLocales = locales.collect(Collectors.groupingBy(Locale::getCountry));</div><div class="line">Map&lt;String, Set&lt;Locale&gt;&gt; countryToLocales = locales.collect(Collectors.groupingBy(Locale::getCountry, toSet())); <span class="comment">// value用set， toSet()为收集器</span></div><div class="line"></div><div class="line">List&lt;Locales&gt; x = countryToLocales.get(“CH”);</div></pre></td></tr></table></figure></p>
<p>所有toMap、groupBy等都有对应的并发版本toCurrentMap、groupByConcurrent</p>
<p>3) 数据分块<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map&lt;Boolean, List&lt;Artist&gt;&gt; map = artists.collect(partitioningBy(Artist::isSolo));</div></pre></td></tr></table></figure></p>
<p>4) 数据分组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map&lt;Artist, List&lt;Album&gt;&gt; map = artists.collect(groupBy(album -&gt; album.getMainMusician()));</div></pre></td></tr></table></figure></p>
<p>5) 组合收集器<br>收集器是生成最终结果的配方，下游收集器则是生成部分结果的配方。<br>mapping允许在收集器的容器上执行类似map的操作，但需指明使用什么样的集合类存储结果，如toList()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Map&lt;Artist, List&lt;String&gt;&gt; map = artists.collect(groupBy(Album::getMainMusician(), mapping(Album::getName, toList())));</div></pre></td></tr></table></figure></p>
<h3 id="6-并行流"><a href="#6-并行流" class="headerlink" title="6.并行流"></a>6.并行流</h3><ul>
<li>parallelStream方法可以将任意串行流装成并行流</li>
<li>Stream.unordered可以不关心顺序，Stream.distinct在无序下性能更好</li>
<li>groupByConcurr使用一个共享的并发map来减少合并map的开销，默认无序</li>
</ul>
<h3 id="7-peek"><a href="#7-peek" class="headerlink" title="7.peek"></a>7.peek</h3><p>peek方法，让你能查看每个值，同时能够继续操作流。在调试时可以用来：</p>
<ul>
<li>打印日志</li>
<li>添加断点，可以像调试循环那样一步步跟踪</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">album.getMusicians()</div><div class="line">     .filter(artist -&gt; artist.getName().startsWith(<span class="string">"The"</span>))</div><div class="line">     .map(artist -&gt; artist.getNationality())</div><div class="line">     .peek(nation -&gt; System.out.println(<span class="string">"Found nationality:"</span> + nation))</div><div class="line">     .collect(Collectors.&lt;String&gt;toSet());</div></pre></td></tr></table></figure>
<h2 id="三、lambda编程"><a href="#三、lambda编程" class="headerlink" title="三、lambda编程"></a>三、lambda编程</h2><h3 id="1、函数式接口"><a href="#1、函数式接口" class="headerlink" title="1、函数式接口"></a>1、函数式接口</h3><p><img src="http://i.imgur.com/FQ5jaOh.png" alt=""></p>
<h3 id="2、自定义函数式接口"><a href="#2、自定义函数式接口" class="headerlink" title="2、自定义函数式接口"></a>2、自定义函数式接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ColorTransformer</span></span>&#123;</div><div class="line">    <span class="function">Color <span class="title">apply</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y,Color colorAtXY)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、泛型"><a href="#3、泛型" class="headerlink" title="3、泛型"></a>3、泛型</h3>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[开机自动后台运行VirtualBox虚拟机]]></title>
      <url>http://fanjun.im/2017/02/%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8CVirtualBox%E8%99%9A%E6%8B%9F%E6%9C%BA.html</url>
      <content type="html"><![CDATA[<h2 id="Step-1、编写脚本"><a href="#Step-1、编写脚本" class="headerlink" title="Step 1、编写脚本"></a>Step 1、编写脚本</h2><p><strong>启动虚拟机脚本: startvm.bat</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@echo off</div><div class="line">&quot;d:\dev\Oracle\VirtualBox\VBoxManage&quot; startvm default --type headless</div></pre></td></tr></table></figure></p>
<p><strong>休眠虚拟机脚本: savestate.bat</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@echo off</div><div class="line">&quot;d:\dev\Oracle\VirtualBox\VBoxManage&quot; controlvm default savestate</div></pre></td></tr></table></figure></p>
<p>注意:</p>
<ul>
<li>“d:\dev\Oracle\VirtualBox\VBoxManage”:VirtualBox的安装目录</li>
<li>default:为虚拟机名字</li>
</ul>
<h2 id="Step-2、添加开关机自动执行"><a href="#Step-2、添加开关机自动执行" class="headerlink" title="Step 2、添加开关机自动执行"></a>Step 2、添加开关机自动执行</h2><p>快捷键<code>&lt;Win&gt; + R</code> 打开运行窗口，输入<code>gpedit.ms</code>c打开组策略，在<code>用户配置-&gt;Windows设置-&gt;脚本（登录/注销）</code>里，分别添加上面2个脚本。<br>现在你已经实现了开机后自动后台运行虚拟机。</p>
<h2 id="附录、VBoxManage命令部分选项解析"><a href="#附录、VBoxManage命令部分选项解析" class="headerlink" title="附录、VBoxManage命令部分选项解析"></a>附录、VBoxManage命令部分选项解析</h2><p>VBoxManage命令可通过命令行修改vm的状态和控制vm的大部分行为。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">d:\Dev\Oracle\VirtualBox&gt;VBoxManage</div><div class="line">Oracle VM VirtualBox Command Line Management Interface Version 5.1.10</div><div class="line">(C) 2005-2016 Oracle Corporation</div><div class="line">All rights reserved.</div><div class="line"></div><div class="line">Usage:</div><div class="line"></div><div class="line">  VBoxManage [&lt;general option&gt;] &lt;command&gt;</div><div class="line"></div><div class="line"></div><div class="line">General Options:</div><div class="line"></div><div class="line">  [-v|--version]            print version number and exit</div><div class="line">  [-q|--nologo]             suppress the logo</div><div class="line">  [--settingspw &lt;pw&gt;]       provide the settings password</div><div class="line">  [--settingspwfile &lt;file&gt;] provide a file containing the settings password</div><div class="line"></div><div class="line"></div><div class="line">Commands:</div><div class="line"></div><div class="line">  list [--long|-l]          vms|runningvms|ostypes|hostdvds|hostfloppies|</div><div class="line">                            intnets|bridgedifs|hostonlyifs|natnets|dhcpservers|</div><div class="line">                            hostinfo|hostcpuids|hddbackends|hdds|dvds|floppies|</div><div class="line">                            usbhost|usbfilters|systemproperties|extpacks|</div><div class="line">                            groups|webcams|screenshotformats</div><div class="line"></div><div class="line">  showvminfo                &lt;uuid|vmname&gt; [--details]</div><div class="line">                            [--machinereadable]</div><div class="line">  showvminfo                &lt;uuid|vmname&gt; --log &lt;idx&gt;</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">  startvm                   &lt;uuid|vmname&gt;...</div><div class="line">                            [--type gui|sdl|headless|separate]</div><div class="line"></div><div class="line">  controlvm                 &lt;uuid|vmname&gt;</div><div class="line">                            pause|resume|reset|poweroff|savestate|</div><div class="line">                            acpipowerbutton|acpisleepbutton|</div><div class="line">                            keyboardputscancode &lt;hex&gt; [&lt;hex&gt; ...]|</div><div class="line"></div><div class="line">...</div></pre></td></tr></table></figure></p>
<ul>
<li>如果要使用uuid，可以通过 VBoxManage list vms查看</li>
<li>startvm命令中type选项解析<ul>
<li>gui – 图形化界面，VirtualBox的默认启动方式</li>
<li>sdl – 图形化界面，但是少掉了部分功能，比如没有菜单等，一般用于调试过程</li>
<li>headless – 后台运行，并且默认开启vrdp服务，可以通过远程桌面工具来访问</li>
<li>separate – 分离式启动，在VirtualBox 5.0版本新增的启动方式：在后台启动虚拟机，分离的前端进程可以关闭，而虚拟机会继续运行</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo Next 主题SEO优化]]></title>
      <url>http://fanjun.im/2016/09/hexo_next_seo.html</url>
      <content type="html"><![CDATA[<p>最近更新了下博客，但是发现在百度和google上都搜索不到，看来是要做下SEO优化了。</p>
<blockquote>
<p>确定是否被搜索引擎录入的方法：在百度或者谷歌上面输入 <code>site: 域名</code> 来判断，如果能搜索到就说明被收录，否则就没有 </p>
</blockquote>
<p>结合网上资料和自己实际优化的结果，整理如下。</p>
<h1 id="针对百度、google的优化"><a href="#针对百度、google的优化" class="headerlink" title="针对百度、google的优化"></a>针对百度、google的优化</h1><h2 id="给你的hexo站点添加sitemap网站地图"><a href="#给你的hexo站点添加sitemap网站地图" class="headerlink" title="给你的hexo站点添加sitemap网站地图"></a>给你的hexo站点添加sitemap网站地图</h2><ol>
<li><p>安装hexo的sitemap网站地图生成插件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install hexo-generator-sitemap --save</div><div class="line">npm install hexo-generator-baidu-sitemap --save</div></pre></td></tr></table></figure>
</li>
<li><p>在你的hexo站点的_config.yml添加下面的代码</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># hexo sitemap网站地图</span></div><div class="line"><span class="attr">sitemap:</span></div><div class="line"><span class="attr">  path:</span> sitemap.xml</div><div class="line"><span class="attr">baidusitemap:</span></div><div class="line"><span class="attr">  path:</span> baidusitemap.xml</div></pre></td></tr></table></figure>
</li>
</ol>
<p>配置成功后，hexo编译时会在hexo站点根目录生成sitemap.xml和baidusitemap.xml</p>
<blockquote>
<p>sitemap.xml适合提交给谷歌搜素引擎<br>baidusitemap.xml适合提交百度搜索引擎。</p>
</blockquote>
<h2 id="给你的hexo网站添加蜘蛛协议robots-txt"><a href="#给你的hexo网站添加蜘蛛协议robots-txt" class="headerlink" title="给你的hexo网站添加蜘蛛协议robots.txt"></a>给你的hexo网站添加蜘蛛协议robots.txt</h2><p>在robots.txt中添加上面生成的sitemap文件，我的配置文件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"># hexo robots.txt</div><div class="line">User-agent: *</div><div class="line">Allow: /</div><div class="line">Allow: /archives/</div><div class="line">Allow: /categories/</div><div class="line">Allow: /about/</div><div class="line">Allow: /tags/</div><div class="line"></div><div class="line">Disallow: /vendors/</div><div class="line">Disallow: /js/</div><div class="line">Disallow: /css/</div><div class="line">Disallow: /fonts/</div><div class="line">Disallow: /vendors/</div><div class="line">Disallow: /fancybox/</div><div class="line"></div><div class="line">Sitemap: http://fanjun.im/sitemap.xml</div><div class="line">Sitemap: http://fanjun.im/baidusitemap.xml</div></pre></td></tr></table></figure></p>
<p>请自行改成自己的网站。<br>把robots.txt放在你的hexo站点的<code>source</code>文件下即可。</p>
<h2 id="让百度、google收录你的博客网站"><a href="#让百度、google收录你的博客网站" class="headerlink" title="让百度、google收录你的博客网站"></a>让百度、google收录你的博客网站</h2><ol>
<li><p>验证你的博客网站<br>首先需要验证你的网站，通过下面的链接访问：<br><a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="external">Google搜索引擎入口</a><br><a href="http://zhanzhang.baidu.com/linksubmit/url" target="_blank" rel="external">百度搜索引擎入口</a><br>由于我使用html页面验证不成功（hexo是单页app，自动将html页面添加到框架中，造成无法验证通过），所以我选择了<code>HTML标签验证</code></p>
<ul>
<li>google验证：<br><img src="http://ocf6s1zuq.bkt.clouddn.com/hexo_next_seo/google-valid-0.png" alt=""><br><img src="http://ocf6s1zuq.bkt.clouddn.com/hexo_next_seo/google-valid.png" alt=""></li>
<li>百度验证：<br><img src="http://ocf6s1zuq.bkt.clouddn.com/hexo_next_seo/baidu-valid-0.png" alt=""><br><img src="http://ocf6s1zuq.bkt.clouddn.com/hexo_next_seo/baidu-valid.png" alt=""></li>
<li>将google和百度的html标签，插入<code>your-hexo-site\themes\next\layout\_partials\head.swig</code> 文件的最后</li>
<li>重新发布文件后，点击<code>完成验证</code>按钮，待提示完成即可</li>
</ul>
</li>
<li><p>收录博客</p>
<ul>
<li>google收录<br>让谷歌收录我们的博客操作比较简单，就是向Google站长工具提交sitemap<br>登录Google账号，添加了站点验证通过后，选择站点，之后在 抓取-&gt; 站点地图 中就能看到<code>添加/测试站点地图</code>，如下图：<br><img src="http://ocf6s1zuq.bkt.clouddn.com/hexo_next_seo/google-sitemap.png" alt=""><br>谷歌提交过了一两天就能搜索到博客了</li>
<li><p>百度收录<br>相比google百度操作可能比较麻烦一点。这里是百度介绍的几种主动提交博客文章链接的方式：</p>
<ol>
<li>主动推送：最为快速的提交方式，推荐您将站点当天新产出链接立即通过此方式推送给百度，以保证新链接可以及时被百度收录。</li>
<li>自动推送：最为便捷的提交方式，请将自动推送的JS代码部署在站点的每一个页面源代码中，部署代码的页面在每次被浏览时，链接会被自动推送给百度。可以与主动推送配合使用。</li>
<li>sitemap：您可以定期将网站链接放到sitemap中，然后将sitemap提交给百度。百度会周期性的抓取检查您提交的sitemap，对其中的链接进行处理，但收录速度慢于主动推送。</li>
<li>手动提交：一次性提交链接给百度，可以使用此种方式。</li>
</ol>
<p>从效率上来说：主动推送&gt;自动推送&gt;sitemap<br>这里介绍自动推送和sitemap提交方式：</p>
<ul>
<li>自动推送<br><img src="http://ocf6s1zuq.bkt.clouddn.com/hexo_next_seo/baidu-push.png" alt=""><br>自动推送是百度站长平台为提高站点新增网页发现速度推出的工具，安装自动推送JS代码的网页，在页面被访问时，页面URL将立即被推送给百度。<br>js代码我是放在<code>your-hexo-site\themes\next\layout\_partials\head.swig</code>中，添加到最下面就行。</li>
<li>sitemap提交<br>直接提交<a href="http://fanjun.im/baidusitemap.xml">http://fanjun.im/baidusitemap.xml</a> 就行，如下图<br><img src="http://ocf6s1zuq.bkt.clouddn.com/hexo_next_seo/baidu-sitemap.png" alt=""><br>我把sitemap.xml和baidusitemap.xml都提交了，反正也没啥坏处。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>至此我们的博客已经被百度与google这样的搜索引擎收录，如果出现无法收录，可以过几天再登录看看结果。<br>下面在说说Hexo本身需要做的优化。</p>
<h1 id="Hexo网站结构优化"><a href="#Hexo网站结构优化" class="headerlink" title="Hexo网站结构优化"></a>Hexo网站结构优化</h1><h2 id="给非友情链接的出站链接添加-“nofollow”-标签"><a href="#给非友情链接的出站链接添加-“nofollow”-标签" class="headerlink" title="给非友情链接的出站链接添加 “nofollow” 标签"></a>给非友情链接的出站链接添加 “nofollow” 标签</h2><p>网络爬虫会在当前页面搜索所有的链接，然后一个个查看，所以就很有可能跳到别的网站就不回来了。这个时候就需要<code>nofollow</code>起作用了。<br><code>nofollow</code>标签是由谷歌领头创新的一个“反垃圾链接”的标签，并被百度、yahoo等各大搜索引擎广泛支持，引用<code>nofollow</code>标签的目的是：用于指示搜索引擎不要追踪（即抓取）网页上的带有<code>nofollow</code>属性的任何出站链接，以减少垃圾链接的分散网站权重。<br>Hexo 的 Next 主题需要改以下几个地方：</p>
<ol>
<li><p>找到<code>footer.swig</code>，路径在<code>your-hexo-site\themes\next\layout\_partials</code>，将下面代码中的<code>a</code>标签加上<code>rel=&quot;external nofollow&quot;</code>属性；</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"theme-link"</span> <span class="attr">href</span>=<span class="string">"http://hexo.io"</span>&gt;</span>Hexo<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">改为</div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"theme-link"</span> <span class="attr">href</span>=<span class="string">"https://hexo.io"</span> <span class="attr">rel</span>=<span class="string">"external nofollow"</span>&gt;</span>Hexo<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"theme-link"</span> <span class="attr">href</span>=<span class="string">"https://github.com/iissnan/hexo-theme-next"</span>&gt;</span></div><div class="line">改为</div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"theme-link"</span> <span class="attr">href</span>=<span class="string">"https://github.com/iissnan/hexo-theme-next"</span> <span class="attr">rel</span>=<span class="string">"external nofollow"</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p>修改<code>sidebar.swig</code>文件，路径在<code>your-hexo-site\themes\next\layout_macro</code>，将下面代码中的<code>a</code>标签加上<code>rel=&quot;external nofollow&quot;</code>属性；</p>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; link &#125;&#125;"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>&#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line">改为</div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123; link &#125;&#125;"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">title</span>=<span class="string">"&#123;&#123; name &#125;&#125;"</span> <span class="attr">rel</span>=<span class="string">"external nofollow"</span>&gt;</span></div></pre></td></tr></table></figure>
 <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://creativecommons.org/&#123;% if theme.creative_commons === 'zero' %&#125;publicdomain/zero/1.0&#123;% else %&#125;licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&#123;% endif %&#125;/"</span> <span class="attr">class</span>=<span class="string">"cc-opacity"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span></div><div class="line">改为</div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://creativecommons.org/&#123;% if theme.creative_commons === 'zero' %&#125;publicdomain/zero/1.0&#123;% else %&#125;licenses/&#123;&#123; theme.creative_commons &#125;&#125;/4.0&#123;% endif %&#125;/"</span> <span class="attr">class</span>=<span class="string">"cc-opacity"</span> <span class="attr">target</span>=<span class="string">"_blank"</span> <span class="attr">rel</span>=<span class="string">"external nofollow"</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="keywords-和-description"><a href="#keywords-和-description" class="headerlink" title="keywords 和 description"></a>keywords 和 description</h2><p>在<code>\scaffolds\post.md</code>中添加如下代码，用于生成的文章中添加关键字和描述。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">keywords:</div><div class="line">description:</div></pre></td></tr></table></figure></p>
<p><strong>新建post的时候记得keywords中输入关键词，会自动转成 <code>&lt;meta name=&quot;keywords&quot; content=&quot;XXX&quot; /&gt;</code></strong></p>
<h2 id="首页title的优化"><a href="#首页title的优化" class="headerlink" title="首页title的优化"></a>首页title的优化</h2><p>更改<code>index.swig</code>文件，文件路径是<code>your-hexo-site\themes\next\layout</code>，修改以下代码<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;% block title %&#125;  &#123;&#123; config.title &#125;&#125;  &#123;% endblock %&#125;</div><div class="line">改成</div><div class="line">&#123;% block title %&#125;  &#123;&#123; config.title &#125;&#125; - &#123;&#123; theme.description &#125;&#125;  &#123;% endblock %&#125;</div></pre></td></tr></table></figure></p>
<h2 id="修改网站链接"><a href="#修改网站链接" class="headerlink" title="修改网站链接"></a>修改网站链接</h2><p>编辑站点<code>_config.yml</code>文件<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># URL</span></div><div class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></div><div class="line"><span class="attr">url:</span> http://fanjun.im</div></pre></td></tr></table></figure></p>
<p>修改为你自己的网站域名。</p>
<h2 id="修改文章链接"><a href="#修改文章链接" class="headerlink" title="修改文章链接"></a>修改文章链接</h2><p>HEXO默认的文章链接形式为<code>domain/year/month/day/postname</code>，默认就是一个四级url，并且可能造成url过长，对搜索引擎是十分不友好的，我们可以改成<code>domain/postname</code> 的形式。<br>编辑站点<code>_config.yml</code>文件，修改其中的permalink字段改为<code>permalink: :title.html</code>即可。</p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.arao.me/2015/hexo-next-theme-optimize-seo/" target="_blank" rel="external">动动手指，不限于NexT主题的Hexo优化（SEO篇）</a><br><a href="http://www.jianshu.com/p/0d54a590b81a" target="_blank" rel="external">Hexo NexT 主题SEO优化指南</a><br><a href="http://www.troylc.cc/hexo/2016/06/16/Hexo-4.html" target="_blank" rel="external">Hexo教程(四)-hexo博客被搜索引擎收录</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[分布式一致性之Paxos、Raft]]></title>
      <url>http://fanjun.im/2016/09/Paxos-Raft.html</url>
      <content type="html"><![CDATA[<h2 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h2><p>Paxos 算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致。一个通用的一致性算法可以应用在许多场景中，是分布式计算中的重要问题。节点通信存在两种模型：共享内存（Shared memory）和消息传递（Messages passing）。Paxos 算法就是一种基于消息传递模型的一致性算法。</p>
<p>Paxos 算法适用的几种情况：一台机器中多个进程/线程达成数据一致；分布式文件系统或者分布式数据库中多客户端并发读写数据；分布式存储中多个副本响应读写请求的一致性。</p>
<p>Paxos 是第一个被证明的一致性算法，其原理基于<code>两阶段提交</code>并进行扩展。作为现在一致性算法设计的鼻祖，以最初论文的难懂出名。<br>算法中将节点分为三种类型：</p>
<ul>
<li>proposer：提出一个提案，等待大家批准为结案。往往是客户端担任该角色；</li>
<li>acceptor：负责对提案进行投票。往往是服务端担任该角色；</li>
<li>learner：被告知结案结果，并与之统一，不参与投票过程。可能为客户端或服务端。</li>
</ul>
<p>并满足三点约束要求：</p>
<ul>
<li>safety：保证决议结果是对的，无歧义的。<ul>
<li>决议（value）只有在被 proposers 提出的 proposal 才能被最终批准；</li>
<li>在一次执行实例中，只批准（chosen）一个最终决议，意味着多数接受（accept）的结果能成为决议；</li>
</ul>
</li>
<li>liveness：保证能在有限时间内正常运行。<ul>
<li>决议总会产生，并且 learners 能获得被批准（chosen）的决议。</li>
</ul>
</li>
</ul>
<p>Paxos 能保证在超过一半的正常节点存在时，系统能达成一致。</p>
<h3 id="第一阶段-Prepare"><a href="#第一阶段-Prepare" class="headerlink" title="第一阶段 Prepare"></a>第一阶段 Prepare</h3><p>P1a：Proposer 发送 Prepare</p>
<blockquote>
<p>Proposer 生成全局唯一且递增的提案 ID（ProposalID，以高位时间戳 + 低位机器 IP 可以保证唯一性和递增性），向 Paxos 集群的所有机器发送 PrepareRequest (ProposalID, 提案内容)。</p>
</blockquote>
<p>P1b：Acceptor 应答 Prepare</p>
<blockquote>
<p>Acceptor 收到 PrepareRequest 后，做出“两个承诺，一个应答”。<br>两个承诺：<br>第一，不再应答 ProposalID 小于等于（注意：这里是 &lt;= ）当前请求的 PrepareRequest；<br>第二，不再应答 ProposalID 小于（注意：这里是 &lt; ）当前请求的 AcceptRequest<br>一个应答：<br>返回自己已经 Accept 过的提案中 ProposalID 最大的那个提案的内容;</p>
</blockquote>
<p><strong>注意</strong>：这<code>两个承诺</code>中，蕴含两个要点：</p>
<pre><code>1.就是应答当前请求前，也要按照`两个承诺`检查是否会违背之前处理 PrepareRequest 时做出的承诺；
2.应答前要在本地持久化当前 PropsalID
</code></pre><p><strong>优化</strong>：在上述 prepare 过程中，如果任何一个结点发现存在一个更高编号的提案，则需要通知 提案人，提醒其中断这次提案。</p>
<h3 id="第二阶段-Accept"><a href="#第二阶段-Accept" class="headerlink" title="第二阶段 Accept"></a>第二阶段 Accept</h3><p>P2a：Proposer 发送 Accept</p>
<blockquote>
<p>Proposer 收集到多数派应答的 PrepareResponse 后，从中选择proposalID最大的提案内容，作为要发起 Accept 的提案。然后携带上当前 ProposalID，向 Paxos 集群的所有机器发送 AccpetRequest。</p>
</blockquote>
<p>P2b：Acceptor 应答 Accept</p>
<blockquote>
<p>Accpetor 收到 AccpetRequest 后，检查不违背自己之前作出的“两个承诺”情况下，持久化当前 ProposalID 和提案内容。最后 Proposer 收集到多数派应答的 AcceptResponse 后，形成决议。</p>
</blockquote>
<p>我们可以看到，这似乎就是一个<code>两段提交</code>的优化。其实，2PC/3PC都是分布式一致性算法的残次版本。<br>Google Chubby的作者Mike Burrows说过:</p>
<pre><code>这个世界上只有一种一致性算法，那就是Paxos，其它的算法都是残次品。
</code></pre><p>我们还可以看到：对于同一个值的在不同结点的修改提案就算是在接收方被乱序收到也是没有问题的。</p>
<h3 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi Paxos"></a>Multi Paxos</h3><p>上述 Basic-Paxos 只是理论模型，在实际工程场景下，比如数据库同步 Redolog，持久化和回放时每条日志都执行完整 Paxos 协议（3 次网络交互，2 次本地持久化），代价过大，需要优化处理。</p>
<blockquote>
<p>Multi Paxos基于Basic Paxos，将原来2-Phase过程简化为了1-Phase，从而加快了提交速度。<br>Multi Paxos要求在各个Proposer中有唯一的Leader，并由这个Leader唯一地提交value给各Acceptor进行表决。在系统中仅有一个Leader进行value提交的情况下，Prepare的过程就可以被跳过，而Leader的选举则可以由Paxos Lease来完成。</p>
</blockquote>
<p>因此使用 Multi-Paxos 协议，要实现如下几个重要功能：</p>
<ul>
<li>自动选主</li>
<li>简化同步逻辑</li>
<li>简化回放逻辑</li>
</ul>
<p>具体的实现请自行google或者参见<a href="## 参考资料">参考资料</a></p>
<h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><p>由于Multi Paxos在理解与实现上的复杂性，提出了Raft协议来简化分布式一致性协议实现的复杂度。</p>
<p>在Raft中，任何时候一个服务器可以扮演下面角色之一：</p>
<ul>
<li>Leader: 处理所有客户端交互，日志复制等，一般一次只有一个Leader.</li>
<li>Follower: 类似选民，完全被动</li>
<li>Candidate候选人: 类似Proposer律师，可以被选为一个新的领导人。</li>
</ul>
<p><img src="https://camo.githubusercontent.com/6396d99ee401327500ef9eafe92617d7812ecd4d/68747470733a2f2f646e2d307830312d696f2e71626f782e6d652f726166742d254535253942254245342d30312e706e67" alt=""></p>
<p>Raft阶段分为两个：</p>
<ul>
<li>选举过程(Leader Election)：首先选举出Leader，然后在选举出来的Leader带领下进行正常操作</li>
<li>日志复制(Log Replication)：所有对系统的修改都会先经过leader，每个修改都会写一条日志(log entry)并且确保大部分节点收到日志</li>
</ul>
<h3 id="选举过程-Leader-Election"><a href="#选举过程-Leader-Election" class="headerlink" title="选举过程 Leader Election"></a>选举过程 Leader Election</h3><p>当follower在选举超时时间(election timeout)内未收到leader的心跳消息(append entries)，则变成candidate状态。<strong>为了避免选举冲突，这个超时时间是一个150~300ms之间的随机数。</strong></p>
<p>成为candidate的结点发起新的选举期(election term)：</p>
<ol>
<li>重置自己的计时器</li>
<li>投自己一票</li>
<li>发送 Request Vote消息<blockquote>
<p>如果接收结点在新term内没有投过票那它就会投给此candidate，并重置它自己的选举超时时间。candidate拉到大部分选票就会成为leader，并定时发送心跳——Append Entries消息，去重置各个follower的计时器。当前Term会继续直到某个follower接收不到心跳并成为candidate。</p>
</blockquote>
</li>
</ol>
<p>如果不巧两个结点同时成为candidate怎么办？</p>
<blockquote>
<p>这时会发生Splite Vote情况。<br>两个结点可能都拉到了同样多的选票，难分胜负，选举失败，本term没有leader。之后又有计时器超时的follower会变成candidate，将term加一并开始新一轮的投票。</p>
</blockquote>
<h3 id="日志复制-Log-Replication"><a href="#日志复制-Log-Replication" class="headerlink" title="日志复制 Log Replication"></a>日志复制 Log Replication</h3><p>Leader收到修改请求后的过程如下： </p>
<ol>
<li>复制日志到所有follower结点(replicate entry)</li>
<li>大多数结点响应时才提交日志</li>
<li>通知所有follower结点日志已提交</li>
<li>所有follower也提交日志</li>
<li>现在整个系统处于一致的状态</li>
</ol>
<p>如果在这一过程中，发生了网络分区或者网络通信故障，会出现什么情况？</p>
<blockquote>
<p>由于网络问题，使得Leader不能访问大多数Follwers了，那么Leader只能正常更新它能访问的那些Follower，而大多数的Follower。<br>因为没有了Leader，他们重新选举一个候选者作为Leader，然后这个Leader作为代表于外界打交道，如果外界要求其添加新的日志，这个新的Leader就按上述步骤通知大多数Followers。<br>如果这时网络故障修复了，那么原先的Leader就变成Follower，在失联阶段这个老Leader的任何更新都不能算commit，都必须回滚，接受新的Leader的新的更新。</p>
</blockquote>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>为了保证整个过程的正确性，Raft算法保证以下属性时刻为真：</p>
<ol>
<li>Election Safety<br>在任意指定Term内，最多选举出一个Leader</li>
<li>Leader Append-Only<br>Leader从不“重写”或者“删除”本地Log，仅仅“追加”本地Log</li>
<li>Log Matching<br>如果两个节点上的日志项拥有相同的Index和Term，那么这两个节点[0, Index]范围内的Log完全一致</li>
<li>Leader Completeness<br>如果某个日志项在某个Term被commit，那么后续任意Term的Leader均拥有该日志项</li>
<li>State Machine Safety<br>一旦某个server将某个日志项应用于本地状态机，以后所有server对于该偏移都将应用相同日志项</li>
</ol>
<p>关于Raft的原理，强烈推荐<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="external">动画版Raft讲解</a>。</p>
<h2 id="Poxos与Raft比较"><a href="#Poxos与Raft比较" class="headerlink" title="Poxos与Raft比较"></a>Poxos与Raft比较</h2><ol>
<li>关于paxos、multi-paxos 的关系<blockquote>
<p>其实paxos 是关于对某一个问题达成一致的一个协议。paxos make simple 花大部分的时间解释的就是一个提案的问题, 然后在结尾的Implementing a State Machine 的章节介绍了我们大部分的应用场景是对一堆连续的问题达成一致, 所以最简单的方法就是实现每一个问题独立运行一个Paxos 的过程, 但是这样每一个问题都需要Prepare, Accept 两个阶段才能够完成。所以我们能不能把这个过程给减少. 那么可以想到的解决方案就是把Prepare 减少, 于是就引入了leader, 引入了leader 就必然有选leader 的过程。才有了后续的事情, 这里可以看出其实lamport 对multi-paxos 的具体实现并没有细节的指定, 只是简单提了一下，所以才有各种不同的multi-paxos 的实现。</p>
</blockquote>
</li>
<li><p>关于paxos 和 raft 的关系</p>
<blockquote>
<p>从上面可以看出其实我们对比的时候不应该拿paxos 和 raft 对比, 因为paxos 是对于一个问题达成一致的协议, 而raft 本身是对一堆连续的问题达成一致的协议. 所以应该比较的是multi-paxos 和raft</p>
</blockquote>
</li>
<li><p>那么multi-paxos 和 raft 的关系是什么呢?</p>
<blockquote>
<p>raft 是基于对multi paxos 的两个限制形成的</p>
<ul>
<li>发送的请求的是连续的, 也就是说raft 的append 操作必须是连续的; 而 multi-paxos 可以并发的 </li>
<li>选主是有限制的, 必须有最新, 最全的日志节点才可以当选; 而multi-paxos 是随意的 </li>
</ul>
</blockquote>
</li>
</ol>
<p>所以raft 可以看成是简化版本的multi paxos</p>
<pre><code>这里multi-paxos 因为允许并发的写log, 因此不存在一个最新、最全的日志节点。 
这样带来的麻烦就是raft选主以后, 需要将Leader里面没有的log 给补全, 并执行commit 过程
</code></pre><p>基于这两个限制，<strong>使得raft 的实现可以更简单, 但是multi-paxos 的并发度理论上是更高的。</strong></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://segmentfault.com/a/1190000004474543" target="_blank" rel="external">2PC到3PC到Paxos到Raft到ISR</a></li>
<li><a href="http://oceanbase.org.cn/?p=111" target="_blank" rel="external">[Paxos三部曲之二] 使用Multi-Paxos协议的日志同步与恢复</a></li>
<li><a href="http://www.cnblogs.com/foxmailed/p/5487533.html" target="_blank" rel="external">使用multi-paxos实现日志同步应用</a></li>
<li><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="external">Raft论文-中文版</a></li>
<li><a href="http://baotiao.github.io/2016/05/05/paxos-raft/" target="_blank" rel="external">谈谈paxos, multi-paxos, raft</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[程序通过ssh/telnet调用shell命令返回乱码问题]]></title>
      <url>http://fanjun.im/2016/09/java-ssh-unreadable-code.html</url>
      <content type="html"><![CDATA[<p><strong>问题描述：</strong><br>在使用java调用ssh协议访问linux的时候，常常发现返回的结果中有乱码，这样的返回结果一般很难解析。如下：<br><img src="http://ocf6s1zuq.bkt.clouddn.com/java-ssh-unreadable-code/unreadable_code.png" alt=""></p>
<p><strong>解决办法：</strong><br>造成这种情况的原因由于linux终端返回的代码中会包含控制代码和转义码，一般是以ESC开头的字符串，详见：<a href="http://www.truevue.org/linux/console-codes" target="_blank" rel="external">http://www.truevue.org/linux/console-codes</a>，一般在返回中以“[00m“的居多，用于指定显示的颜色、加粗等。<br>程序中需要去除这些字符，可以通过正则表达式：<code>\e\[.*?m|\e\].*?;</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[分布式事务之二阶段提交、三阶段提交]]></title>
      <url>http://fanjun.im/2016/08/2PC_3PC.html</url>
      <content type="html"><![CDATA[<h2 id="分布式事务及其实现机制"><a href="#分布式事务及其实现机制" class="headerlink" title="分布式事务及其实现机制"></a>分布式事务及其实现机制</h2><blockquote>
<p>分布式事务是指会涉及到操作多个数据库（或者提供事务语义的系统，如JMS）的事务。其实就是将对同一数据库事务的概念扩大到了对多个数据库的事务。目的是为了保证分布式系统中事务操作的原子性。分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果（全部提交或全部回滚）。</p>
</blockquote>
<p>与本地事务类似，分布式事务也包含原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。<br>分布式事务的实现技术如下表所示(以DBMS作为事务参与方为例)</p>
<table>
<thead>
<tr>
<th>分布式ACID</th>
<th>实现技术</th>
</tr>
</thead>
<tbody>
<tr>
<td>原子性（Atomicity）</td>
<td>MVCC + 两阶段提交</td>
</tr>
<tr>
<td>一致性（Consistency）</td>
<td>约束（主键、外键等）</td>
</tr>
<tr>
<td>隔离性</td>
<td>MVCC</td>
</tr>
<tr>
<td>持久性</td>
<td>WAL</td>
</tr>
</tbody>
</table>
<p>从上表可以看到，一致性、隔离性和持久性靠的是各分布式事务参与方自己原有的机制，<strong>两阶段提交主要用来保证分布式事务的原子性</strong>。</p>
<h2 id="2PC（二阶段提交）"><a href="#2PC（二阶段提交）" class="headerlink" title="2PC（二阶段提交）"></a>2PC（二阶段提交）</h2><p><img src="http://ocf6s1zuq.bkt.clouddn.com/2PC_3PC/2PC.png" alt="2PC流程"></p>
<p>在两阶段提交协议中，包含了两种角色：</p>
<ul>
<li>协调者：协调者就是处理分布式事务的节点</li>
<li>参与者：事务管理器,实际处理事务的节点</li>
</ul>
<p>该算法分为两个阶段：</p>
<h3 id="准备阶段-投票阶段"><a href="#准备阶段-投票阶段" class="headerlink" title="准备阶段(投票阶段)"></a>准备阶段(投票阶段)</h3><blockquote>
<p>1）协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应<br>2）各参与者节点执行事务操作，并将Undo和Redo信息计入事务日志中<br>3）如果参与者成功执行了事务操作，那么就反馈给协调者<code>Yes</code>响应，表示事务可以执行；如果参与者没有成功执行事务，那么就反馈给协调者<code>No</code>响应，表示事务不可以执行。</p>
</blockquote>
<h3 id="提交阶段（执行阶段）"><a href="#提交阶段（执行阶段）" class="headerlink" title="提交阶段（执行阶段）"></a>提交阶段（执行阶段）</h3><p>接下来分两种情况分别讨论提交阶段的过程</p>
<pre><code>a.当协调者节点从所有参与者节点获得的相应消息都为`YES`时：
</code></pre><blockquote>
<p>1）协调者节点向所有参与者节点发出<code>commit</code>的请求<br>2）参与者节点正式完成操作，并释放在整个事务期间内占用的资源<br>3）参与者节点向协调者节点发送<code>完成</code>消息<br>4）协调者节点受到所有参与者节点反馈的<code>完成</code>消息后，完成事务</p>
</blockquote>
<pre><code>b.如果任一参与者节点在第一阶段返回的响应消息为`NO`，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：
</code></pre><blockquote>
<p>1）协调者节点向所有参与者节点发出<code>rollback</code>的请求<br>2）参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源<br>3）参与者节点向协调者节点发送<code>回滚完成</code>消息<br>4）协调者节点受到所有参与者节点反馈的<code>回滚完成</code>消息后，取消事务</p>
</blockquote>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong>：原理简单、实现方便<br><strong>缺点</strong>：同步阻塞、单点问题、数据不一致</p>
<ol>
<li><strong>同步阻塞问题</strong>。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</li>
<li><strong>单点故障</strong>。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。</li>
<li><strong>数据不一致</strong>。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这会导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作,但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</li>
</ol>
<p>由于二阶段提交存在着诸如同步阻塞、单点问题、脑裂等缺陷，所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。</p>
<h2 id="3PC（三阶段提交）"><a href="#3PC（三阶段提交）" class="headerlink" title="3PC（三阶段提交）"></a>3PC（三阶段提交）</h2><p>三阶段提交（是二阶段提交（2PC）的改进版本。与两阶段提交不同的是，三阶段提交有两个改动点：</p>
<ol>
<li>引入超时机制。同时在协调者和参与者中都引入超时机制。</li>
<li>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</li>
</ol>
<p>也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。<br><img src="http://ocf6s1zuq.bkt.clouddn.com/2PC_3PC/3PC.png" alt="3PC流程"></p>
<h3 id="CanCommit"><a href="#CanCommit" class="headerlink" title="CanCommit"></a>CanCommit</h3><blockquote>
<p>1）协调者向各参与者发送<code>CanCommit</code>的请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应<br>2）参与者收到<code>CanCommit</code>请求后，正常情况下，如果自身认为可以顺利执行事务，那么会反馈<code>Yes</code>响应，并进入预备状态，否则反馈<code>No</code></p>
</blockquote>
<h3 id="PreCommit"><a href="#PreCommit" class="headerlink" title="PreCommit"></a>PreCommit</h3><pre><code>a.如果协调者接收到各参与者反馈都是Yes，那么执行事务预提交
</code></pre><blockquote>
<p>1）协调者向各参与者发送<code>preCommit</code>请求，并进入<code>prepared</code>阶段<br>2）参与者接收到<code>preCommit</code>请求后，会执行事务操作，并将Undo和Redo信息记录到事务日记中<br>3）如果各参与者都成功执行了事务操作，那么反馈给协调者<code>Ack</code>响应，同时等待最终指令，提交<code>commit</code>或者终止<code>abort</code></p>
</blockquote>
<pre><code>b.如果任何一个参与者向协调者反馈了No响应，或者在等待超时后，协调者无法接收到所有参与者的反馈，那么就会中断事务。
</code></pre><blockquote>
<p>1）协调者向所有参与者发送<code>abort</code>请求<br>2）无论是收到来自协调者的<code>abort</code>请求，还是等待超时，参与者都中断事务</p>
</blockquote>
<h3 id="doCommit"><a href="#doCommit" class="headerlink" title="doCommit"></a>doCommit</h3><pre><code>a.假设协调者正常工作，接收到了所有参与者的ack响应，那么它将从预提交阶段进入提交状态
</code></pre><blockquote>
<p>1）协调者向所有参与者发送<code>doCommit</code>请求<br>2）参与者收到<code>doCommit</code>请求后，正式提交事务，并在完成事务提交后释放占用的资源<br>3）参与者完成事务提交后，向协调者发送<code>ACK</code>信息<br>4）协调者接收到所有参与者<code>ack</code>信息，完成事务</p>
</blockquote>
<pre><code>b.假设协调者正常工作，并且有任一参与者反馈No，或者在等待超时后无法接收所有参与者的反馈，都会中断事务
</code></pre><blockquote>
<p>1）协调者向所有参与者节点发送<code>abort</code>请求<br>2）参与者接收到<code>abort</code>请求后，利用undo日志执行事务回滚并在完成事务回滚后释放占用的资源<br>3）参与者在完成事务回滚之后，向协调者发送<code>ack</code>信息<br>4）协调者接收到所有参与者反馈的<code>ack</code>信息后，中断事务</p>
</blockquote>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong>：降低参与者阻塞范围，并能够在出现单点故障后继续达成一致<br><strong>缺点</strong>：doCommit阶段，如果出现网络分区，协调者无法与参与者正常通信，参与者依然会进行事务提交，造成数据不一致。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>了解了2PC和3PC之后，我们可以发现虽然它们可以解决分布式事务中的原子性问题；但无论是二阶段提交还是三阶段提交都无法彻底解决分布式中的副本一致性问题。<br>后面的文章，我会介绍分布式一致性协议：Paxos、Raft。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://blog.jobbole.com/95632/" target="_blank" rel="external">关于分布式事务、两阶段提交协议、三阶提交协议</a></li>
<li><a href="http://www.jasongj.com/big_data/two_phase_commit/" target="_blank" rel="external">分布式事务（一）两阶段提交及JTA</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>http://fanjun.im/2016/08/hello-world.html</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    </entry>
    
  
  
</search>
