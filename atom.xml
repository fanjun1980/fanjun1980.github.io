<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FanJun&#39;s Blog</title>
  <subtitle>Stay hungry. Stay foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fanjun.im/"/>
  <updated>2016-09-24T06:30:19.455Z</updated>
  <id>http://fanjun.im/</id>
  
  <author>
    <name>fanjun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo Next 主题SEO优化</title>
    <link href="http://fanjun.im/2016/09/hexo_next_seo.html"/>
    <id>http://fanjun.im/2016/09/hexo_next_seo.html</id>
    <published>2016-09-24T05:38:00.000Z</published>
    <updated>2016-09-24T06:30:19.455Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="SEO" scheme="http://fanjun.im/categories/SEO/"/>
    
    
      <category term="Hexo" scheme="http://fanjun.im/tags/Hexo/"/>
    
      <category term="Next" scheme="http://fanjun.im/tags/Next/"/>
    
      <category term="SEO" scheme="http://fanjun.im/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>分布式一致性之Paxos、Raft</title>
    <link href="http://fanjun.im/2016/09/Paxos-Raft.html"/>
    <id>http://fanjun.im/2016/09/Paxos-Raft.html</id>
    <published>2016-09-10T06:14:04.000Z</published>
    <updated>2016-09-24T06:30:35.047Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h2><p>Paxos 算法解决的问题是一个分布式系统如何就某个值（决议）达成一致。一个典型的场景是，在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点执行相同的操作序列，那么他们最后能得到一个一致的状态。为保证每个节点执行相同的命令序列，需要在每一条指令上执行一个“一致性算法”以保证每个节点看到的指令一致。一个通用的一致性算法可以应用在许多场景中，是分布式计算中的重要问题。节点通信存在两种模型：共享内存（Shared memory）和消息传递（Messages passing）。Paxos 算法就是一种基于消息传递模型的一致性算法。</p>
<p>Paxos 算法适用的几种情况：一台机器中多个进程/线程达成数据一致；分布式文件系统或者分布式数据库中多客户端并发读写数据；分布式存储中多个副本响应读写请求的一致性。</p>
<p>Paxos 是第一个被证明的一致性算法，其原理基于<code>两阶段提交</code>并进行扩展。作为现在一致性算法设计的鼻祖，以最初论文的难懂出名。<br>算法中将节点分为三种类型：</p>
<ul>
<li>proposer：提出一个提案，等待大家批准为结案。往往是客户端担任该角色；</li>
<li>acceptor：负责对提案进行投票。往往是服务端担任该角色；</li>
<li>learner：被告知结案结果，并与之统一，不参与投票过程。可能为客户端或服务端。</li>
</ul>
<p>并满足三点约束要求：</p>
<ul>
<li>safety：保证决议结果是对的，无歧义的。<ul>
<li>决议（value）只有在被 proposers 提出的 proposal 才能被最终批准；</li>
<li>在一次执行实例中，只批准（chosen）一个最终决议，意味着多数接受（accept）的结果能成为决议；</li>
</ul>
</li>
<li>liveness：保证能在有限时间内正常运行。<ul>
<li>决议总会产生，并且 learners 能获得被批准（chosen）的决议。</li>
</ul>
</li>
</ul>
<p>Paxos 能保证在超过一半的正常节点存在时，系统能达成一致。</p>
<h3 id="第一阶段-Prepare"><a href="#第一阶段-Prepare" class="headerlink" title="第一阶段 Prepare"></a>第一阶段 Prepare</h3><p>P1a：Proposer 发送 Prepare</p>
<blockquote>
<p>Proposer 生成全局唯一且递增的提案 ID（ProposalID，以高位时间戳 + 低位机器 IP 可以保证唯一性和递增性），向 Paxos 集群的所有机器发送 PrepareRequest (ProposalID, 提案内容)。</p>
</blockquote>
<p>P1b：Acceptor 应答 Prepare</p>
<blockquote>
<p>Acceptor 收到 PrepareRequest 后，做出“两个承诺，一个应答”。<br>两个承诺：<br>第一，不再应答 ProposalID 小于等于（注意：这里是 &lt;= ）当前请求的 PrepareRequest；<br>第二，不再应答 ProposalID 小于（注意：这里是 &lt; ）当前请求的 AcceptRequest<br>一个应答：<br>返回自己已经 Accept 过的提案中 ProposalID 最大的那个提案的内容;</p>
</blockquote>
<p><strong>注意</strong>：这<code>两个承诺</code>中，蕴含两个要点：</p>
<pre><code>1.就是应答当前请求前，也要按照`两个承诺`检查是否会违背之前处理 PrepareRequest 时做出的承诺；
2.应答前要在本地持久化当前 PropsalID
</code></pre><p><strong>优化</strong>：在上述 prepare 过程中，如果任何一个结点发现存在一个更高编号的提案，则需要通知 提案人，提醒其中断这次提案。</p>
<h3 id="第二阶段-Accept"><a href="#第二阶段-Accept" class="headerlink" title="第二阶段 Accept"></a>第二阶段 Accept</h3><p>P2a：Proposer 发送 Accept</p>
<blockquote>
<p>Proposer 收集到多数派应答的 PrepareResponse 后，从中选择proposalID最大的提案内容，作为要发起 Accept 的提案。然后携带上当前 ProposalID，向 Paxos 集群的所有机器发送 AccpetRequest。</p>
</blockquote>
<p>P2b：Acceptor 应答 Accept</p>
<blockquote>
<p>Accpetor 收到 AccpetRequest 后，检查不违背自己之前作出的“两个承诺”情况下，持久化当前 ProposalID 和提案内容。最后 Proposer 收集到多数派应答的 AcceptResponse 后，形成决议。</p>
</blockquote>
<p>我们可以看到，这似乎就是一个<code>两段提交</code>的优化。其实，2PC/3PC都是分布式一致性算法的残次版本。<br>Google Chubby的作者Mike Burrows说过:</p>
<pre><code>这个世界上只有一种一致性算法，那就是Paxos，其它的算法都是残次品。
</code></pre><p>我们还可以看到：对于同一个值的在不同结点的修改提案就算是在接收方被乱序收到也是没有问题的。</p>
<h3 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi Paxos"></a>Multi Paxos</h3><p>上述 Basic-Paxos 只是理论模型，在实际工程场景下，比如数据库同步 Redolog，持久化和回放时每条日志都执行完整 Paxos 协议（3 次网络交互，2 次本地持久化），代价过大，需要优化处理。</p>
<blockquote>
<p>Multi Paxos基于Basic Paxos，将原来2-Phase过程简化为了1-Phase，从而加快了提交速度。<br>Multi Paxos要求在各个Proposer中有唯一的Leader，并由这个Leader唯一地提交value给各Acceptor进行表决。在系统中仅有一个Leader进行value提交的情况下，Prepare的过程就可以被跳过，而Leader的选举则可以由Paxos Lease来完成。</p>
</blockquote>
<p>因此使用 Multi-Paxos 协议，要实现如下几个重要功能：</p>
<ul>
<li>自动选主</li>
<li>简化同步逻辑</li>
<li>简化回放逻辑</li>
</ul>
<p>具体的实现请自行google或者参见<a href="## 参考资料">参考资料</a></p>
<h2 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h2><p>由于Multi Paxos在理解与实现上的复杂性，提出了Raft协议来简化分布式一致性协议实现的复杂度。</p>
<p>在Raft中，任何时候一个服务器可以扮演下面角色之一：</p>
<ul>
<li>Leader: 处理所有客户端交互，日志复制等，一般一次只有一个Leader.</li>
<li>Follower: 类似选民，完全被动</li>
<li>Candidate候选人: 类似Proposer律师，可以被选为一个新的领导人。</li>
</ul>
<p><img src="https://camo.githubusercontent.com/6396d99ee401327500ef9eafe92617d7812ecd4d/68747470733a2f2f646e2d307830312d696f2e71626f782e6d652f726166742d254535253942254245342d30312e706e67" alt=""></p>
<p>Raft阶段分为两个：</p>
<ul>
<li>选举过程(Leader Election)：首先选举出Leader，然后在选举出来的Leader带领下进行正常操作</li>
<li>日志复制(Log Replication)：所有对系统的修改都会先经过leader，每个修改都会写一条日志(log entry)并且确保大部分节点收到日志</li>
</ul>
<h3 id="选举过程-Leader-Election"><a href="#选举过程-Leader-Election" class="headerlink" title="选举过程 Leader Election"></a>选举过程 Leader Election</h3><p>当follower在选举超时时间(election timeout)内未收到leader的心跳消息(append entries)，则变成candidate状态。<strong>为了避免选举冲突，这个超时时间是一个150~300ms之间的随机数。</strong></p>
<p>成为candidate的结点发起新的选举期(election term)：</p>
<ol>
<li>重置自己的计时器</li>
<li>投自己一票</li>
<li>发送 Request Vote消息<blockquote>
<p>如果接收结点在新term内没有投过票那它就会投给此candidate，并重置它自己的选举超时时间。candidate拉到大部分选票就会成为leader，并定时发送心跳——Append Entries消息，去重置各个follower的计时器。当前Term会继续直到某个follower接收不到心跳并成为candidate。</p>
</blockquote>
</li>
</ol>
<p>如果不巧两个结点同时成为candidate怎么办？</p>
<blockquote>
<p>这时会发生Splite Vote情况。<br>两个结点可能都拉到了同样多的选票，难分胜负，选举失败，本term没有leader。之后又有计时器超时的follower会变成candidate，将term加一并开始新一轮的投票。</p>
</blockquote>
<h3 id="日志复制-Log-Replication"><a href="#日志复制-Log-Replication" class="headerlink" title="日志复制 Log Replication"></a>日志复制 Log Replication</h3><p>Leader收到修改请求后的过程如下： </p>
<ol>
<li>复制日志到所有follower结点(replicate entry)</li>
<li>大多数结点响应时才提交日志</li>
<li>通知所有follower结点日志已提交</li>
<li>所有follower也提交日志</li>
<li>现在整个系统处于一致的状态</li>
</ol>
<p>如果在这一过程中，发生了网络分区或者网络通信故障，会出现什么情况？</p>
<blockquote>
<p>由于网络问题，使得Leader不能访问大多数Follwers了，那么Leader只能正常更新它能访问的那些Follower，而大多数的Follower。<br>因为没有了Leader，他们重新选举一个候选者作为Leader，然后这个Leader作为代表于外界打交道，如果外界要求其添加新的日志，这个新的Leader就按上述步骤通知大多数Followers。<br>如果这时网络故障修复了，那么原先的Leader就变成Follower，在失联阶段这个老Leader的任何更新都不能算commit，都必须回滚，接受新的Leader的新的更新。</p>
</blockquote>
<h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>为了保证整个过程的正确性，Raft算法保证以下属性时刻为真：</p>
<ol>
<li>Election Safety<br>在任意指定Term内，最多选举出一个Leader</li>
<li>Leader Append-Only<br>Leader从不“重写”或者“删除”本地Log，仅仅“追加”本地Log</li>
<li>Log Matching<br>如果两个节点上的日志项拥有相同的Index和Term，那么这两个节点[0, Index]范围内的Log完全一致</li>
<li>Leader Completeness<br>如果某个日志项在某个Term被commit，那么后续任意Term的Leader均拥有该日志项</li>
<li>State Machine Safety<br>一旦某个server将某个日志项应用于本地状态机，以后所有server对于该偏移都将应用相同日志项</li>
</ol>
<p>关于Raft的原理，强烈推荐<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="external">动画版Raft讲解</a>。</p>
<h2 id="Poxos与Raft比较"><a href="#Poxos与Raft比较" class="headerlink" title="Poxos与Raft比较"></a>Poxos与Raft比较</h2><ol>
<li>关于paxos、multi-paxos 的关系<blockquote>
<p>其实paxos 是关于对某一个问题达成一致的一个协议。paxos make simple 花大部分的时间解释的就是一个提案的问题, 然后在结尾的Implementing a State Machine 的章节介绍了我们大部分的应用场景是对一堆连续的问题达成一致, 所以最简单的方法就是实现每一个问题独立运行一个Paxos 的过程, 但是这样每一个问题都需要Prepare, Accept 两个阶段才能够完成。所以我们能不能把这个过程给减少. 那么可以想到的解决方案就是把Prepare 减少, 于是就引入了leader, 引入了leader 就必然有选leader 的过程。才有了后续的事情, 这里可以看出其实lamport 对multi-paxos 的具体实现并没有细节的指定, 只是简单提了一下，所以才有各种不同的multi-paxos 的实现。</p>
</blockquote>
</li>
<li><p>关于paxos 和 raft 的关系</p>
<blockquote>
<p>从上面可以看出其实我们对比的时候不应该拿paxos 和 raft 对比, 因为paxos 是对于一个问题达成一致的协议, 而raft 本身是对一堆连续的问题达成一致的协议. 所以应该比较的是multi-paxos 和raft</p>
</blockquote>
</li>
<li><p>那么multi-paxos 和 raft 的关系是什么呢?</p>
<blockquote>
<p>raft 是基于对multi paxos 的两个限制形成的</p>
<ul>
<li>发送的请求的是连续的, 也就是说raft 的append 操作必须是连续的; 而 multi-paxos 可以并发的 </li>
<li>选主是有限制的, 必须有最新, 最全的日志节点才可以当选; 而multi-paxos 是随意的 </li>
</ul>
</blockquote>
</li>
</ol>
<p>所以raft 可以看成是简化版本的multi paxos</p>
<pre><code>这里multi-paxos 因为允许并发的写log, 因此不存在一个最新、最全的日志节点。 
这样带来的麻烦就是raft选主以后, 需要将Leader里面没有的log 给补全, 并执行commit 过程
</code></pre><p>基于这两个限制，<strong>使得raft 的实现可以更简单, 但是multi-paxos 的并发度理论上是更高的。</strong></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="https://segmentfault.com/a/1190000004474543" target="_blank" rel="external">2PC到3PC到Paxos到Raft到ISR</a></li>
<li><a href="http://oceanbase.org.cn/?p=111" target="_blank" rel="external">[Paxos三部曲之二] 使用Multi-Paxos协议的日志同步与恢复</a></li>
<li><a href="http://www.cnblogs.com/foxmailed/p/5487533.html" target="_blank" rel="external">使用multi-paxos实现日志同步应用</a></li>
<li><a href="https://github.com/maemual/raft-zh_cn/blob/master/raft-zh_cn.md" target="_blank" rel="external">Raft论文-中文版</a></li>
<li><a href="http://baotiao.github.io/2016/05/05/paxos-raft/" target="_blank" rel="external">谈谈paxos, multi-paxos, raft</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      Paxos、Raft是目前解决分布式一致性的主要方法，本文重点介绍这2个协议的原理与关系
    
    </summary>
    
      <category term="分布式" scheme="http://fanjun.im/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://fanjun.im/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="协议" scheme="http://fanjun.im/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>程序通过ssh/telnet调用shell命令返回乱码问题</title>
    <link href="http://fanjun.im/2016/09/java-ssh-unreadable-code.html"/>
    <id>http://fanjun.im/2016/09/java-ssh-unreadable-code.html</id>
    <published>2016-09-03T15:41:37.000Z</published>
    <updated>2016-09-24T06:32:21.047Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题描述：</strong><br>在使用java调用ssh协议访问linux的时候，常常发现返回的结果中有乱码，这样的返回结果一般很难解析。如下：<br><img src="http://ocf6s1zuq.bkt.clouddn.com/java-ssh-unreadable-code/unreadable_code.png" alt=""></p>
<p><strong>解决办法：</strong><br>造成这种情况的原因由于linux终端返回的代码中会包含控制代码和转义码，一般是以ESC开头的字符串，详见：<a href="http://www.truevue.org/linux/console-codes" target="_blank" rel="external">http://www.truevue.org/linux/console-codes</a>，一般在返回中以“[00m“的居多，用于指定显示的颜色、加粗等。<br>程序中需要去除这些字符，可以通过正则表达式：<code>\e\[.*?m|\e\].*?;</code></p>
]]></content>
    
    <summary type="html">
    
      程序通过ssh/telnet调用远程服务器上的shell命令时经常会返回一些乱码，影响返回结果的正常解析。本文分析这种情况出现的原因及解决办法。
    
    </summary>
    
      <category term="java" scheme="http://fanjun.im/categories/java/"/>
    
    
      <category term="编程经验" scheme="http://fanjun.im/tags/%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务之二阶段提交、三阶段提交</title>
    <link href="http://fanjun.im/2016/08/2PC_3PC.html"/>
    <id>http://fanjun.im/2016/08/2PC_3PC.html</id>
    <published>2016-08-18T15:17:06.000Z</published>
    <updated>2016-09-24T06:31:50.038Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式事务及其实现机制"><a href="#分布式事务及其实现机制" class="headerlink" title="分布式事务及其实现机制"></a>分布式事务及其实现机制</h2><blockquote>
<p>分布式事务是指会涉及到操作多个数据库（或者提供事务语义的系统，如JMS）的事务。其实就是将对同一数据库事务的概念扩大到了对多个数据库的事务。目的是为了保证分布式系统中事务操作的原子性。分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果（全部提交或全部回滚）。</p>
</blockquote>
<p>与本地事务类似，分布式事务也包含原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。<br>分布式事务的实现技术如下表所示(以DBMS作为事务参与方为例)</p>
<table>
<thead>
<tr>
<th>分布式ACID</th>
<th>实现技术</th>
</tr>
</thead>
<tbody>
<tr>
<td>原子性（Atomicity）</td>
<td>MVCC + 两阶段提交</td>
</tr>
<tr>
<td>一致性（Consistency）</td>
<td>约束（主键、外键等）</td>
</tr>
<tr>
<td>隔离性</td>
<td>MVCC</td>
</tr>
<tr>
<td>持久性</td>
<td>WAL</td>
</tr>
</tbody>
</table>
<p>从上表可以看到，一致性、隔离性和持久性靠的是各分布式事务参与方自己原有的机制，<strong>两阶段提交主要用来保证分布式事务的原子性</strong>。</p>
<h2 id="2PC（二阶段提交）"><a href="#2PC（二阶段提交）" class="headerlink" title="2PC（二阶段提交）"></a>2PC（二阶段提交）</h2><p><img src="http://ocf6s1zuq.bkt.clouddn.com/2PC_3PC/2PC.png" alt="2PC流程"></p>
<p>在两阶段提交协议中，包含了两种角色：</p>
<ul>
<li>协调者：协调者就是处理分布式事务的节点</li>
<li>参与者：事务管理器,实际处理事务的节点</li>
</ul>
<p>该算法分为两个阶段：</p>
<h3 id="准备阶段-投票阶段"><a href="#准备阶段-投票阶段" class="headerlink" title="准备阶段(投票阶段)"></a>准备阶段(投票阶段)</h3><blockquote>
<p>1）协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应<br>2）各参与者节点执行事务操作，并将Undo和Redo信息计入事务日志中<br>3）如果参与者成功执行了事务操作，那么就反馈给协调者<code>Yes</code>响应，表示事务可以执行；如果参与者没有成功执行事务，那么就反馈给协调者<code>No</code>响应，表示事务不可以执行。</p>
</blockquote>
<h3 id="提交阶段（执行阶段）"><a href="#提交阶段（执行阶段）" class="headerlink" title="提交阶段（执行阶段）"></a>提交阶段（执行阶段）</h3><p>接下来分两种情况分别讨论提交阶段的过程</p>
<pre><code>a.当协调者节点从所有参与者节点获得的相应消息都为`YES`时：
</code></pre><blockquote>
<p>1）协调者节点向所有参与者节点发出<code>commit</code>的请求<br>2）参与者节点正式完成操作，并释放在整个事务期间内占用的资源<br>3）参与者节点向协调者节点发送<code>完成</code>消息<br>4）协调者节点受到所有参与者节点反馈的<code>完成</code>消息后，完成事务</p>
</blockquote>
<pre><code>b.如果任一参与者节点在第一阶段返回的响应消息为`NO`，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：
</code></pre><blockquote>
<p>1）协调者节点向所有参与者节点发出<code>rollback</code>的请求<br>2）参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源<br>3）参与者节点向协调者节点发送<code>回滚完成</code>消息<br>4）协调者节点受到所有参与者节点反馈的<code>回滚完成</code>消息后，取消事务</p>
</blockquote>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong>：原理简单、实现方便<br><strong>缺点</strong>：同步阻塞、单点问题、数据不一致</p>
<ol>
<li><strong>同步阻塞问题</strong>。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</li>
<li><strong>单点故障</strong>。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。</li>
<li><strong>数据不一致</strong>。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这会导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作,但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。</li>
</ol>
<p>由于二阶段提交存在着诸如同步阻塞、单点问题、脑裂等缺陷，所以，研究者们在二阶段提交的基础上做了改进，提出了三阶段提交。</p>
<h2 id="3PC（三阶段提交）"><a href="#3PC（三阶段提交）" class="headerlink" title="3PC（三阶段提交）"></a>3PC（三阶段提交）</h2><p>三阶段提交（是二阶段提交（2PC）的改进版本。与两阶段提交不同的是，三阶段提交有两个改动点：</p>
<ol>
<li>引入超时机制。同时在协调者和参与者中都引入超时机制。</li>
<li>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。</li>
</ol>
<p>也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。<br><img src="http://ocf6s1zuq.bkt.clouddn.com/2PC_3PC/3PC.png" alt="3PC流程"></p>
<h3 id="CanCommit"><a href="#CanCommit" class="headerlink" title="CanCommit"></a>CanCommit</h3><blockquote>
<p>1）协调者向各参与者发送<code>CanCommit</code>的请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应<br>2）参与者收到<code>CanCommit</code>请求后，正常情况下，如果自身认为可以顺利执行事务，那么会反馈<code>Yes</code>响应，并进入预备状态，否则反馈<code>No</code></p>
</blockquote>
<h3 id="PreCommit"><a href="#PreCommit" class="headerlink" title="PreCommit"></a>PreCommit</h3><pre><code>a.如果协调者接收到各参与者反馈都是Yes，那么执行事务预提交
</code></pre><blockquote>
<p>1）协调者向各参与者发送<code>preCommit</code>请求，并进入<code>prepared</code>阶段<br>2）参与者接收到<code>preCommit</code>请求后，会执行事务操作，并将Undo和Redo信息记录到事务日记中<br>3）如果各参与者都成功执行了事务操作，那么反馈给协调者<code>Ack</code>响应，同时等待最终指令，提交<code>commit</code>或者终止<code>abort</code></p>
</blockquote>
<pre><code>b.如果任何一个参与者向协调者反馈了No响应，或者在等待超时后，协调者无法接收到所有参与者的反馈，那么就会中断事务。
</code></pre><blockquote>
<p>1）协调者向所有参与者发送<code>abort</code>请求<br>2）无论是收到来自协调者的<code>abort</code>请求，还是等待超时，参与者都中断事务</p>
</blockquote>
<h3 id="doCommit"><a href="#doCommit" class="headerlink" title="doCommit"></a>doCommit</h3><pre><code>a.假设协调者正常工作，接收到了所有参与者的ack响应，那么它将从预提交阶段进入提交状态
</code></pre><blockquote>
<p>1）协调者向所有参与者发送<code>doCommit</code>请求<br>2）参与者收到<code>doCommit</code>请求后，正式提交事务，并在完成事务提交后释放占用的资源<br>3）参与者完成事务提交后，向协调者发送<code>ACK</code>信息<br>4）协调者接收到所有参与者<code>ack</code>信息，完成事务</p>
</blockquote>
<pre><code>b.假设协调者正常工作，并且有任一参与者反馈No，或者在等待超时后无法接收所有参与者的反馈，都会中断事务
</code></pre><blockquote>
<p>1）协调者向所有参与者节点发送<code>abort</code>请求<br>2）参与者接收到<code>abort</code>请求后，利用undo日志执行事务回滚并在完成事务回滚后释放占用的资源<br>3）参与者在完成事务回滚之后，向协调者发送<code>ack</code>信息<br>4）协调者接收到所有参与者反馈的<code>ack</code>信息后，中断事务</p>
</blockquote>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p><strong>优点</strong>：降低参与者阻塞范围，并能够在出现单点故障后继续达成一致<br><strong>缺点</strong>：doCommit阶段，如果出现网络分区，协调者无法与参与者正常通信，参与者依然会进行事务提交，造成数据不一致。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>了解了2PC和3PC之后，我们可以发现虽然它们可以解决分布式事务中的原子性问题；但无论是二阶段提交还是三阶段提交都无法彻底解决分布式中的副本一致性问题。<br>后面的文章，我会介绍分布式一致性协议：Paxos、Raft。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a href="http://blog.jobbole.com/95632/" target="_blank" rel="external">关于分布式事务、两阶段提交协议、三阶提交协议</a></li>
<li><a href="http://www.jasongj.com/big_data/two_phase_commit/" target="_blank" rel="external">分布式事务（一）两阶段提交及JTA</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      两阶段提交与三阶段提交是保证分布式事务中原子性的重要方法，本文重点介绍这2个协议的原理与局限性
    
    </summary>
    
      <category term="分布式" scheme="http://fanjun.im/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="分布式" scheme="http://fanjun.im/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="协议" scheme="http://fanjun.im/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://fanjun.im/2016/08/hello-world.html"/>
    <id>http://fanjun.im/2016/08/hello-world.html</id>
    <published>2016-08-12T08:57:17.371Z</published>
    <updated>2016-08-12T14:13:11.727Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;http://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;http://hexo.io
    
    </summary>
    
    
  </entry>
  
</feed>
